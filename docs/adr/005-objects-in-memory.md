# Проблема
Нужно реализовать кэш в памяти для blob-storage, который будет работать на стороне сервера.

# Решение
Будет реализован кэш SoftReference на byte[]

## SoftReference vs WeakReference
Выбор в пользу SoftReference обусловлен тем, что кэш будер работать на стороне сервиса и должен переживать 
не одну сборку GC.

## byte[] vs ByteBuffer.allocate() vs ByteBuffer.allocateDirect()

### ByteBuffer.allocateDirect 
ByteBuffer.allocateDirect выделяет объект в нативной памяти OS. Скорее всего будет самый быстрый но и самый 
рискованный вариант. JVM будет пытаться выполнять IO операции непосредственно на этом буфере. Но SoftReference на 
ByteBuffer может очень долго (пока хватает памяти самой JVM), что может привести нехватке нативной памяти. 

## ByteBuffer.allocate
ByteBuffer - это некая обертка над массивом байт. Массив байт при вызове ByteBuffer.allocate создается в куче JVM. 
При получении данных из кэша придется вызывать ByteBuffer.duplicate() и надеятся(?) что JVM сможет применить оптимизации IO
с буфером внутри хипа. 

Если в кэше будут ByteBuffer, то сначала GC будет вынужден зачищать объекты ByteBuffer, которые сами по себе не очень 
большие по сравнению с массивами байт и только потом уже чистить массивы байт, на которые не осталось ссылок. Возможна 
ситуация, что даже вычистив весь кэш места не остентся и GC будет вынужден делать FullScan. 

##  byte[]
Предполагается использовать nio, поэтому так и так придется создавать ByteBuffer обертки. Но GC должен очищать кэщ более 
плавно в идеале без FullGC.

Нужен конечно нагрузочный тест - но аналитически пока остановился на byte[]

